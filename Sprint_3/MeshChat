Programa MeshChat V1

---- MainActivity.kt ----
'''java
package com.example.chatdirect

import android.Manifest
import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.PackageManager
import android.net.NetworkInfo
import android.net.wifi.p2p.WifiP2pConfig
import android.net.wifi.p2p.WifiP2pDevice
import android.net.wifi.p2p.WifiP2pInfo
import android.net.wifi.p2p.WifiP2pManager
import android.net.wifi.p2p.nsd.WifiP2pDnsSdServiceInfo
import android.net.wifi.p2p.nsd.WifiP2pDnsSdServiceRequest
import android.os.Build
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Person
import androidx.compose.material.icons.filled.Send
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.ElevatedButton
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.ListItem
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextField
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.core.app.ActivityCompat
import com.example.chatdirect.ui.theme.ChatdirectTheme
import java.io.IOException
import java.io.InputStream
import java.io.OutputStream
import java.net.InetAddress
import java.net.ServerSocket
import java.net.Socket
import java.util.concurrent.Executors

@OptIn(ExperimentalMaterial3Api::class)
class MainActivity : ComponentActivity(), WifiP2pManager.ConnectionInfoListener {

    private lateinit var manager: WifiP2pManager
    private lateinit var channel: WifiP2pManager.Channel
    private lateinit var receiver: BroadcastReceiver
    private lateinit var intentFilter: IntentFilter

    private var peers by mutableStateOf<List<WifiP2pDevice>>(emptyList())
    private var isConnected by mutableStateOf(false)
    private var messages by mutableStateOf<List<String>>(emptyList())
    private var currentMessage by mutableStateOf("")
    private var sendReceive: SendReceive? = null

    private val peerListListener = WifiP2pManager.PeerListListener { peerList ->
        val refreshedPeers = peerList.deviceList.toList()
        Log.d("MainActivity", "PeerListListener found ${refreshedPeers.size} peers (not used for app list).")
    }

    private val serviceListener = WifiP2pManager.DnsSdServiceResponseListener { instanceName, _, srcDevice ->
        if (instanceName.equals(SERVICE_INSTANCE, ignoreCase = true)) {
            if (peers.none { it.deviceAddress == srcDevice.deviceAddress }) {
                peers = peers + srcDevice
                Log.d("MainActivity", "ChatDirect service discovered on device: ${srcDevice.deviceName}")
            }
        }
    }

    private val txtRecordListener = WifiP2pManager.DnsSdTxtRecordListener { _, _, _ -> }

    private val handler = Handler(Looper.getMainLooper()) { msg ->
        when (msg.what) {
            MESSAGE_READ -> {
                val readBuff = msg.obj as ByteArray
                val tempMsg = String(readBuff, 0, msg.arg1)
                messages = messages + "Amigo: $tempMsg"
                true
            }
            else -> false
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()

        manager = getSystemService(Context.WIFI_P2P_SERVICE) as WifiP2pManager
        channel = manager.initialize(this, mainLooper, null)

        receiver = WiFiDirectBroadcastReceiver(manager, channel, this, this, peerListListener)
        intentFilter = IntentFilter().apply {
            addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION)
            addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION)
            addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)
            addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION)
        }

        manager.setDnsSdResponseListeners(channel, serviceListener, txtRecordListener)

        setContent {
            ChatdirectTheme {
                Scaffold(
                    modifier = Modifier.fillMaxSize(),
                    topBar = {
                        if (isConnected) {
                            TopAppBar(
                                title = { Text("Chat Activo") },
                                navigationIcon = {
                                    IconButton(onClick = { disconnect() }) {
                                        Icon(Icons.Default.ArrowBack, contentDescription = "Desconectar y volver")
                                    }
                                }
                            )
                        }
                    }
                ) { innerPadding ->
                    if (isConnected) {
                        ChatScreen(
                            modifier = Modifier.padding(innerPadding),
                            messages = messages,
                            currentMessage = currentMessage,
                            onCurrentMessageChange = { currentMessage = it },
                            onSendMessage = { sendMessage() }
                        )
                    } else {
                        DeviceDiscoveryScreen(
                            modifier = Modifier.padding(innerPadding),
                            peers = peers,
                            onDiscoverClick = { discoverServices() },
                            onPeerClick = { device -> connect(device) }
                        )
                    }
                }
            }
        }
    }

    fun onConnectionStateChange(connected: Boolean) {
        isConnected = connected
        if (!connected) {
            messages = emptyList()
        }
    }
    
    private fun disconnect() {
        sendReceive?.closeSocket()
        sendReceive = null
        manager.removeGroup(channel, object : WifiP2pManager.ActionListener {
            override fun onSuccess() {
                Log.d("MainActivity", "Disconnected successfully.")
            }

            override fun onFailure(reason: Int) {
                Log.e("MainActivity", "Failed to disconnect. Reason: $reason")
            }
        })
    }

    private fun sendMessage() {
        if (currentMessage.isNotBlank()) {
            val executor = Executors.newSingleThreadExecutor()
            executor.execute {
                sendReceive?.write(currentMessage.toByteArray())
                handler.post {
                    messages = messages + "Yo: $currentMessage"
                    currentMessage = ""
                }
            }
        }
    }

    @SuppressLint("MissingPermission")
    private fun startLocalServiceRegistration() {
        val record: Map<String, String> = mapOf(
            "listenport" to "8888",
            "devicename" to "ChatDirectDevice"
        )
        val serviceInfo = WifiP2pDnsSdServiceInfo.newInstance(SERVICE_INSTANCE, SERVICE_TYPE, record)

        manager.addLocalService(channel, serviceInfo, object : WifiP2pManager.ActionListener {
            override fun onSuccess() {
                Log.d("MainActivity", "Local service registered successfully.")
            }
            override fun onFailure(reason: Int) {
                Log.e("MainActivity", "Failed to register local service. Reason: $reason")
            }
        })
    }

    override fun onResume() {
        super.onResume()
        registerReceiver(receiver, intentFilter)
        startLocalServiceRegistration()
    }

    override fun onPause() {
        super.onPause()
        unregisterReceiver(receiver)
        manager.clearLocalServices(channel, object : WifiP2pManager.ActionListener {
            override fun onSuccess() {
                Log.d("MainActivity", "Local services cleared.")
            }
            override fun onFailure(reason: Int) {
                Log.e("MainActivity", "Failed to clear local services. Reason: $reason")
            }
        })
    }

    @SuppressLint("MissingPermission")
    private fun discoverServices() {
        val permissionsToRequest = mutableListOf<String>()
        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
            permissionsToRequest.add(Manifest.permission.ACCESS_FINE_LOCATION)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.NEARBY_WIFI_DEVICES) != PackageManager.PERMISSION_GRANTED) {
                permissionsToRequest.add(Manifest.permission.NEARBY_WIFI_DEVICES)
            }
        }

        if (permissionsToRequest.isNotEmpty()) {
            ActivityCompat.requestPermissions(this, permissionsToRequest.toTypedArray(), 1)
            Log.d("MainActivity", "Permissions not granted, requesting.")
            return
        }
        
        peers = emptyList()
        val serviceRequest = WifiP2pDnsSdServiceRequest.newInstance()
        manager.addServiceRequest(channel, serviceRequest, object : WifiP2pManager.ActionListener {
            override fun onSuccess() {
                Log.d("MainActivity", "Service request added.")
                manager.discoverServices(channel, object : WifiP2pManager.ActionListener {
                    override fun onSuccess() {
                        Log.d("MainActivity", "Service discovery initiated.")
                    }
                    override fun onFailure(reason: Int) {
                        Log.e("MainActivity", "Service discovery failed. Reason: $reason")
                    }
                })
            }
            override fun onFailure(reason: Int) {
                Log.e("MainActivity", "Failed to add service request. Reason: $reason")
            }
        })
    }

    @SuppressLint("MissingPermission")
    private fun connect(device: WifiP2pDevice) {
        val config = WifiP2pConfig().apply {
            deviceAddress = device.deviceAddress
        }
        manager.connect(channel, config, object : WifiP2pManager.ActionListener {
            override fun onSuccess() {
                Log.d("MainActivity", "Connection to ${device.deviceName} initiated successfully.")
            }

            override fun onFailure(reason: Int) {
                Log.e("MainActivity", "Connection to ${device.deviceName} failed. Reason: $reason")
            }
        })
    }

    override fun onConnectionInfoAvailable(info: WifiP2pInfo) {
        val groupOwnerAddress: InetAddress? = info.groupOwnerAddress

        if (info.groupFormed && info.isGroupOwner && groupOwnerAddress != null) {
            Log.d("MainActivity", "I am the group owner (server)")
            ServerClass().start()
            handler.post { isConnected = true }
        } else if (info.groupFormed && groupOwnerAddress != null) {
            Log.d("MainActivity", "I am a client")
            ClientClass(groupOwnerAddress).start()
            handler.post { isConnected = true }
        } else {
             Log.d("MainActivity", "Connection lost or failed.")
             onConnectionStateChange(false)
        }
    }
    
    companion object {
        const val MESSAGE_READ = 1
        private const val SERVICE_INSTANCE = "_chatdirect"
        private const val SERVICE_TYPE = "_presence._tcp"
    }
    
    inner class ServerClass : Thread() {
        override fun run() {
            try {
                val serverSocket = ServerSocket(8888)
                val socket = serverSocket.accept()
                sendReceive = SendReceive(socket)
                sendReceive?.start()
            } catch (e: IOException) {
                e.printStackTrace()
                Log.e("MainActivity", "ServerClass IOException: ${e.message}")
            }
        }
    }

    inner class ClientClass(private val hostAddress: InetAddress) : Thread() {
        override fun run() {
            try {
                val socket = Socket()
                socket.connect(java.net.InetSocketAddress(hostAddress, 8888), 500)
                sendReceive = SendReceive(socket)
                sendReceive?.start()
            } catch (e: IOException) {
                e.printStackTrace()
                Log.e("MainActivity", "ClientClass IOException: ${e.message}")
            }
        }
    }

    inner class SendReceive(private val socket: Socket) : Thread() {
        private val inputStream: InputStream = socket.inputStream
        private val outputStream: OutputStream = socket.outputStream

        override fun run() {
            val buffer = ByteArray(1024)
            var bytes: Int

            while (socket.isConnected) {
                try {
                    bytes = inputStream.read(buffer)
                    if (bytes > 0) {
                        handler.obtainMessage(MESSAGE_READ, bytes, -1, buffer).sendToTarget()
                    }
                } catch (e: IOException) {
                    e.printStackTrace()
                    Log.e("MainActivity", "SendReceive Exception: ${e.message}")
                    break
                }
            }
        }

        fun write(bytes: ByteArray) {
            try {
                outputStream.write(bytes)
            } catch (e: IOException) {
                e.printStackTrace()
                Log.e("MainActivity", "SendReceive write Exception: ${e.message}")
            }
        }

        fun closeSocket() {
            try {
                socket.close()
            } catch (e: IOException) {
                Log.e("MainActivity", "Error closing socket", e)
            }
        }
    }
}

class WiFiDirectBroadcastReceiver(
    private val manager: WifiP2pManager,
    private val channel: WifiP2pManager.Channel,
    private val activity: MainActivity,
    private val connectionInfoListener: WifiP2pManager.ConnectionInfoListener,
    private val peerListListener: WifiP2pManager.PeerListListener
) : BroadcastReceiver() {

    @SuppressLint("MissingPermission")
    override fun onReceive(context: Context, intent: Intent) {
        when (intent.action) {
            WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION -> {
                val state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1)
                 if (state == WifiP2pManager.WIFI_P2P_STATE_ENABLED) {
                    Log.d("WiFiDirectBroadcastReceiver", "Wi-Fi P2P is enabled.")
                } else {
                    Log.e("WiFiDirectBroadcastReceiver", "Wi-Fi P2P is not enabled. Please enable it in system settings.")
                }
            }
            WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION -> {
                 if (ActivityCompat.checkSelfPermission(
                        context,
                        Manifest.permission.ACCESS_FINE_LOCATION
                    ) != PackageManager.PERMISSION_GRANTED
                ) {
                     Log.e("WiFiDirectBroadcastReceiver", "Permission check failed for requestPeers")
                    return
                }
                manager.requestPeers(channel, peerListListener)
            }
            WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION -> {
                val networkInfo = intent.getParcelableExtra<NetworkInfo>(WifiP2pManager.EXTRA_NETWORK_INFO)
                if (networkInfo?.isConnected == true) {
                    manager.requestConnectionInfo(channel, connectionInfoListener)
                    Log.d("WiFiDirectBroadcastReceiver", "Device connected")
                } else {
                     (activity as MainActivity).onConnectionStateChange(false)
                    Log.d("WiFiDirectBroadcastReceiver", "Device disconnected")
                }
            }
            WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION -> {}
        }
    }
}


@Composable
fun DeviceDiscoveryScreen(
    modifier: Modifier = Modifier,
    peers: List<WifiP2pDevice>,
    onDiscoverClick: () -> Unit,
    onPeerClick: (WifiP2pDevice) -> Unit
) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        ElevatedButton(
            onClick = onDiscoverClick,
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Buscar usuarios de ChatDirect")
        }

        Spacer(modifier = Modifier.height(16.dp))

        if (peers.isEmpty()) {
            Column(
                modifier = Modifier.fillMaxSize(),
                verticalArrangement = Arrangement.Center,
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text("No se encontraron usuarios de ChatDirect.")
                Text("Toca el botón para iniciar la búsqueda.")
            }
        } else {
             Text(
                "Usuarios de ChatDirect Encontrados",
                style = MaterialTheme.typography.titleLarge,
                modifier = Modifier
                    .padding(bottom = 8.dp)
                    .align(Alignment.Start)
            )
            LazyColumn(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(peers) { peer ->
                    Card(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { onPeerClick(peer) },
                        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
                    ) {
                        ListItem(
                            headlineContent = { Text(peer.deviceName ?: "Dispositivo sin nombre") },
                            supportingContent = { Text(peer.deviceAddress) },
                            leadingContent = {
                                Icon(
                                    Icons.Default.Person,
                                    contentDescription = "Icono de dispositivo"
                                )
                            }
                        )
                    }
                }
            }
        }
    }
}

@Composable
fun ChatScreen(
    modifier: Modifier = Modifier,
    messages: List<String>,
    currentMessage: String,
    onCurrentMessageChange: (String) -> Unit,
    onSendMessage: () -> Unit
) {
    Column(
        modifier = modifier.fillMaxSize().padding(horizontal = 16.dp)
    ) {
        LazyColumn(
            modifier = Modifier.weight(1f).fillMaxWidth(),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            items(messages) { message ->
                Text(message, style = MaterialTheme.typography.bodyLarge, modifier = Modifier.padding(vertical = 4.dp))
            }
        }
        Row(
            modifier = Modifier.fillMaxWidth().padding(top = 8.dp, bottom = 8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            TextField(
                value = currentMessage,
                onValueChange = onCurrentMessageChange,
                modifier = Modifier.weight(1f),
                placeholder = { Text("Escribe un mensaje...") }
            )
            IconButton(onClick = onSendMessage, enabled = currentMessage.isNotBlank()) {
                Icon(Icons.Default.Send, contentDescription = "Enviar mensaje")
            }
        }
    }
}


@Preview(showBackground = true)
@Composable
fun DeviceDiscoveryScreenPreview() {
    ChatdirectTheme {
        val dummyDevice = WifiP2pDevice().apply {
            deviceName = "Teléfono de Prueba"
            deviceAddress = "A1:B2:C3:D4:E5:F6"
        }
        DeviceDiscoveryScreen(peers = listOf(dummyDevice), onDiscoverClick = {}, onPeerClick = {})
    }
}

@Preview(showBackground = true)
@Composable
fun ChatScreenPreview() {
    ChatdirectTheme {
        ChatScreen(
            messages = listOf("Yo: Hola!", "Amigo: ¡Hola! ¿Qué tal?"),
            currentMessage = "Escribiendo...",
            onCurrentMessageChange = {},
            onSendMessage = {}
        )
    }
}
'''

