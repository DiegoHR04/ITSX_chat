--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
AndroidManifest.xml	
Declara permisos (Internet, WiFi, ubicación) y registra la actividad principal
Permite a la app:
✔ Usar Internet
✔ Activar/cambiar el Wi-Fi
✔ Buscar dispositivos cercanos (requiere ubicación)
✔ Usar Wi-Fi Direct

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.wifidirectchat">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
    <!-- Required since Android M for peer discovery -->
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />

    <!-- Wi-Fi Direct feature (optional: device may not support) -->
    <uses-feature android:name="android.hardware.wifi.direct" android:required="false" />

    <application
        android:allowBackup="true"
        android:label="WiFi-Direct Chat"
        android:theme="@style/Theme.AppCompat.Light.NoActionBar">
        <activity android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
    </application>

</manifest>


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
activity_main.xml
La interfaz gráfica del chat (botones, mensajes, campo de texto)


<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:padding="12dp"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!-- Estado y acciones -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:paddingBottom="8dp">

        <Button
            android:id="@+id/btnDiscover"
            android:layout_width="0dp"
            android:layout_weight="1"
            android:layout_height="wrap_content"
            android:text="Descubrir peers" />

        <Button
            android:id="@+id/btnDisconnect"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Desconectar"
            android:layout_marginStart="8dp"/>
    </LinearLayout>

    <!-- Lista de peers -->
    <TextView
        android:id="@+id/tvPeers"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Peers encontrados:"
        android:paddingBottom="8dp"/>

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:background="#f0f0f0"
        android:padding="8dp">

        <TextView
            android:id="@+id/tvChat"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text=""
            android:autoLink="none"/>
    </ScrollView>

    <!-- Campo para enviar -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:paddingTop="8dp">

        <EditText
            android:id="@+id/etMessage"
            android:layout_width="0dp"
            android:layout_weight="1"
            android:layout_height="wrap_content"
            android:hint="Mensaje"/>

        <Button
            android:id="@+id/btnSend"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Enviar"
            android:layout_marginStart="8dp"/>
    </LinearLayout>

</LinearLayout>




--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
MainActivity.kt	
Controla toda la lógica de WiFi Direct, conexión P2P y la interfaz del usuario
Funciones clave: 
Wi-Fi Direct Inicializa WifiP2pManager Descubre dispositivos cercanos (peers) Se conecta a un peer automáticamente Recibe información cuando hay conexión o desconexión y en el chat Envía mensajes desde el botón “Enviar” Muestra los mensajes recibidos en la pantalla.

package com.example.wifidirectchat

import android.Manifest
import android.content.*
import android.net.wifi.p2p.*
import android.os.Bundle
import android.util.Log
import android.widget.*
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import kotlinx.coroutines.*
import java.net.InetAddress

class MainActivity : AppCompatActivity() {

    private lateinit var manager: WifiP2pManager
    private var channel: WifiP2pManager.Channel? = null
    private var receiver: WiFiDirectBroadcastReceiver? = null
    private lateinit var intentFilter: IntentFilter

    private lateinit var btnDiscover: Button
    private lateinit var btnDisconnect: Button
    private lateinit var btnSend: Button
    private lateinit var etMessage: EditText
    private lateinit var tvChat: TextView
    private lateinit var tvPeers: TextView

    private val peers = mutableListOf<WifiP2pDevice>()
    private var isGroupOwner = false
    private var groupOwnerAddress: InetAddress? = null

    private var chatService: ChatService? = null

    private val locationPermissionLauncher =
        registerForActivityResult(ActivityResultContracts.RequestPermission()) { granted ->
            if (!granted) {
                Toast.makeText(this, "Necesitamos permiso de ubicación para discovery", Toast.LENGTH_LONG).show()
            }
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        btnDiscover = findViewById(R.id.btnDiscover)
        btnDisconnect = findViewById(R.id.btnDisconnect)
        btnSend = findViewById(R.id.btnSend)
        etMessage = findViewById(R.id.etMessage)
        tvChat = findViewById(R.id.tvChat)
        tvPeers = findViewById(R.id.tvPeers)

        // init wifi p2p
        manager = getSystemService(WIFI_P2P_SERVICE) as WifiP2pManager
        channel = manager.initialize(this, mainLooper, null)

        chatService = ChatService { msg ->
            runOnUiThread {
                appendChat(msg)
            }
        }

        // Intents para el BroadcastReceiver
        intentFilter = IntentFilter().apply {
            addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION)
            addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION)
            addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)
            addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION)
        }
        receiver = WiFiDirectBroadcastReceiver(manager, channel, this)

        btnDiscover.setOnClickListener { startPeerDiscovery() }
        btnDisconnect.setOnClickListener { disconnect() }
        btnSend.setOnClickListener {
            val text = etMessage.text.toString().trim()
            if (text.isNotEmpty()) {
                chatService?.sendMessage(text)
                etMessage.setText("")
            }
        }

        // solicitar permiso de ubicación (requerido para discovery en Android)
        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)
            != android.content.pm.PackageManager.PERMISSION_GRANTED) {
            locationPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)
        }
    }

    override fun onResume() {
        super.onResume()
        registerReceiver(receiver, intentFilter)
    }

    override fun onPause() {
        super.onPause()
        try { unregisterReceiver(receiver) } catch(_: Exception) {}
    }

    // UI helpers
    fun appendChat(text: String) {
        tvChat.append(text + "\n")
    }

    // Callbacks from receiver
    fun onP2pStateChanged(enabled: Boolean) {
        appendChat("P2P estado: ${if (enabled) "Habilitado" else "No habilitado"}")
    }

    fun onPeersAvailable(deviceList: Collection<WifiP2pDevice>) {
        peers.clear()
        peers.addAll(deviceList)
        val sb = StringBuilder()
        peers.forEachIndexed { idx, d ->
            sb.append("${idx+1}. ${d.deviceName} - ${d.deviceAddress}\n")
        }
        tvPeers.text = "Peers encontrados:\n${sb.toString()}"
        // Si hay peers, opcional: auto-conectar al primero (para demo)
        // Aquí dejo que el usuario elija; por simplicidad me conecto al primero si hay alguno
        if (peers.isNotEmpty()) {
            connectToPeer(peers.first())
        }
    }

    fun onConnectionInfoAvailable(info: WifiP2pInfo) {
        isGroupOwner = info.isGroupOwner
        groupOwnerAddress = info.groupOwnerAddress
        appendChat("Conexión establecida. isGroupOwner=$isGroupOwner addr=${groupOwnerAddress?.hostAddress}")

        // Iniciar servicio de chat: si soy owner -> startServer. Sino -> connectTo owner
        if (isGroupOwner) {
            chatService?.startServer() // escucha en puerto 8888
        } else {
            groupOwnerAddress?.let { addr ->
                chatService?.connectTo(addr)
            }
        }
    }

    fun onDisconnected() {
        appendChat("Desconectado")
        chatService?.stopAll()
    }

    private fun startPeerDiscovery() {
        // pedir permiso de ubicación si hace falta
        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)
            != android.content.pm.PackageManager.PERMISSION_GRANTED) {
            locationPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)
            return
        }

        manager.discoverPeers(channel, object : WifiP2pManager.ActionListener {
            override fun onSuccess() {
                appendChat("Busqueda iniciada")
            }

            override fun onFailure(reason: Int) {
                appendChat("Error al iniciar búsqueda: $reason")
            }
        })
    }

    private fun connectToPeer(device: WifiP2pDevice) {
        val config = WifiP2pConfig().apply {
            deviceAddress = device.deviceAddress
            wps.setup = WpsInfo.PBC
        }
        manager.connect(channel, config, object : WifiP2pManager.ActionListener {
            override fun onSuccess() {
                appendChat("Conectando a ${device.deviceName} ...")
            }

            override fun onFailure(reason: Int) {
                appendChat("Fallo al conectar: $reason")
            }
        })
    }

    private fun disconnect() {
        manager.removeGroup(channel, object : WifiP2pManager.ActionListener {
            override fun onSuccess() {
                appendChat("Grupo eliminado / desconectado")
                chatService?.stopAll()
            }

            override fun onFailure(reason: Int) {
                appendChat("Fallo al desconectar: $reason")
            }
        })
    }
}



------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
WiFiDirectBroadcastReceiver.kt	
Detecta los cambios en el estado del Wi-Fi Direct y notifica a la actividad

package com.example.wifidirectchat

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.net.wifi.p2p.WifiP2pManager
import android.util.Log

class WiFiDirectBroadcastReceiver(
    private val manager: WifiP2pManager?,
    private val channel: WifiP2pManager.Channel?,
    private val activity: MainActivity
) : BroadcastReceiver() {

    override fun onReceive(context: Context?, intent: Intent?) {
        val action = intent?.action
        when (action) {
            WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION -> {
                val state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1)
                activity.onP2pStateChanged(state == WifiP2pManager.WIFI_P2P_STATE_ENABLED)
            }

            WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION -> {
                manager?.requestPeers(channel) { peers ->
                    activity.onPeersAvailable(peers.deviceList)
                }
            }

            WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION -> {
                manager?.let { mgr ->
                    val networkInfo = intent.getParcelableExtra<android.net.NetworkInfo>(WifiP2pManager.EXTRA_NETWORK_INFO)
                    if (networkInfo?.isConnected == true) {
                        mgr.requestConnectionInfo(channel) { info ->
                            activity.onConnectionInfoAvailable(info)
                        }
                    } else {
                        activity.onDisconnected()
                    }
                }
            }

            WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION -> {
                // podría manejar cambios en este dispositivo si se desea
            }
        }
    }
}


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ChatService.kt	
Maneja los sockets (envío/recepción de mensajes) entre los teléfonos, los sokets usados son:
startServer()	Crea un servidor y espera que se conecten
connectTo()	Se conecta como cliente al servidor (Group Owner)
sendMessage()	Envía texto por el socket
handleSocket()	Lee y recibe mensajes del otro equipo
stopAll()	Cierra conexiones





package com.example.wifidirectchat

import kotlinx.coroutines.*
import java.io.*
import java.net.InetAddress
import java.net.ServerSocket
import java.net.Socket

class ChatService(private val onMessage: (String) -> Unit) {
    private var serverJob: Job? = null
    private var clientSocket: Socket? = null
    private var serverSocket: ServerSocket? = null
    private var writer: BufferedWriter? = null

    // Ejecutar servidor si soy group owner
    fun startServer(port: Int = 8888) {
        stopAll()
        serverJob = CoroutineScope(Dispatchers.IO).launch {
            try {
                serverSocket = ServerSocket(port)
                onMessage("Servicio: esperando conexión en puerto $port")
                val socket = serverSocket!!.accept()
                onMessage("Servicio: cliente conectado: ${socket.inetAddress.hostAddress}")
                handleSocket(socket)
            } catch (e: Exception) {
                onMessage("Servicio (server) error: ${e.localizedMessage}")
            }
        }
    }

    // Conectar como cliente al host (group owner)
    fun connectTo(host: InetAddress, port: Int = 8888) {
        stopAll()
        serverJob = CoroutineScope(Dispatchers.IO).launch {
            try {
                onMessage("Servicio: conectando a ${host.hostAddress}:$port ...")
                clientSocket = Socket(host, port)
                onMessage("Servicio: conectado a ${host.hostAddress}")
                handleSocket(clientSocket!!)
            } catch (e: Exception) {
                onMessage("Servicio (client) error: ${e.localizedMessage}")
            }
        }
    }

    private fun handleSocket(socket: Socket) {
        try {
            val input = BufferedReader(InputStreamReader(socket.getInputStream()))
            writer = BufferedWriter(OutputStreamWriter(socket.getOutputStream()))
            // Lectura continua
            while (!socket.isClosed) {
                val line = input.readLine() ?: break
                onMessage("Otro: $line")
            }
        } catch (e: Exception) {
            onMessage("Servicio (handle) error: ${e.localizedMessage}")
        } finally {
            try { socket.close() } catch(_: Exception) {}
        }
    }

    fun sendMessage(text: String) {
        CoroutineScope(Dispatchers.IO).launch {
            try {
                writer?.let {
                    it.write(text)
                    it.newLine()
                    it.flush()
                    onMessage("Yo: $text")
                } ?: onMessage("Servicio: sin conexión para enviar")
            } catch (e: Exception) {
                onMessage("Servicio (send) error: ${e.localizedMessage}")
            }
        }
    }

    fun stopAll() {
        serverJob?.cancel()
        serverJob = null
        try { clientSocket?.close() } catch(_: Exception) {}
        clientSocket = null
        try { serverSocket?.close() } catch(_: Exception) {}
        serverSocket = null
        writer = null
    }
}
